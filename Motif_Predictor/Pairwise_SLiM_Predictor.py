#This script takes protein sequences and computes their SLiM scores based on the results of make_pairwise_matrices.py

#Import required functions and packages

import numpy as np
import pandas as pd
import time
import glob
import os
import pickle
import warnings
from am_functions import CharacAA, FilenameSubdir, ListInputter
from am_vars import list_aa_no_phos

# Function to import an additional parallel scoring method (not part of public repo) for scoring SLiMs if one exists
def get_private_method():
	try:
		from Private.Method import imported_scorer
		return True
	except:
		warnings.warn("Import failed; ensure that the scoring function is named imported_scorer and placed in a script at /Motif_Predictor/Private/Method.py")
		print("Proceeding without a parallel method.")
		return False

# Function to import dictionary of conditional weighted matrices generated by make_pairwise_matrices.py
def import_weighted_matrices():
	pickled_matrices_dir = os.path.join(os.getcwd(), "temp", "conditional_weighted_matrices.pkl")
	if os.path.exists(pickled_matrices_dir):
		with open(pickled_matrices_dir, "wb") as f:
			unpickled_matrices_dict = pickle.load(f)
	else:
		raise Exception("Source matrices not found; expected path: " + pickled_matrices_dir)

	# Construct dictionary of matrices by position that returns lists
	unpickled_lists_dict = {}
	for key, value_df in unpickled_matrices_dict.items():
		for n in np.arange(1, motif_length + 1):
			new_key = key + "_#" + str(n) + "_list"
			new_value_list = value_df.loc[:, "#" + str(n)].values.tolist()
			unpickled_lists_dict[new_key] = new_value_list

	return unpickled_matrices_dict, unpickled_lists_dict

# Function for inputting rules for use in manual_rule_checker
def manual_rule_definer(frame_length):
	manual_rules_dict = {}
	print("Defining manual rules that, when broken, cause a motif to be immediately rejected.")
	for i in np.arange(1, frame_length + 1): 
		manual_rule = input("At position " + str(i) + ", do you want a manual rule? (Y/n)  ")
		if manual_rule == "Y": 
			residues_allowed = ListInputter("Requiring the following residues at position #" + str(i) + ":")
			manual_rules_dict[i] = residues_allowed
	return manual_rules_dict

# Function to reject motifs not following manual rules; increases speed massively
def manual_rule_checker(seq_input, rules_dict):
	seq_input_length = len(seq_input)
	rule_broken = False
	for position, allowed_residues in rules_dict.items(): 
		seq_at_position = seq_input[position - 1]
		if seq_at_position not in allowed_residues: 
			rule_broken = True
	return rule_broken

# Function to find motifs in a protein sequence
def motif_finder(sequence, length, target_motif_length, rules):
	# Define dictionary to get index of an amino acid for matrix lookup
	index_aa_dict = {"D": 0, "E": 1, "R": 2, "H": 3, "K": 4, "S": 5, "T": 6, "N": 7, "Q": 8, "C": 9, "G": 10, "P": 11,
					 "A": 12, "V": 13, "I": 14, "L": 15, "M": 16, "F": 17, "Y": 18, "W": 19}

	target_motif_positions = np.arange(target_motif_length)

	possible_motifs = length - target_motif_length + 1

	first_score = 0
	second_score = 0
	first_motif = ""
	second_motif = ""

	for i in np.arange(0, possible_motifs): 
		score = 0 #Declares variable
		motif_start = i.item()
		motif_end = motif_start + motif_length
		motif_seq = sequence[motif_start:motif_end]

		#Ensures sequences with incomputable/incomplete sequences are not considered
		if "B" in motif_seq or "J" in motif_seq or "O" in motif_seq or "U" in motif_seq or "X" in motif_seq or "Z" in motif_seq: 
			continue

		#Check manual rules
		motif_rule_broken = manual_rule_checker(motif_seq, rules)
		if motif_rule_broken:
			continue

		for j in target_motif_positions: 
			residue = motif_seq[j]
			residue_row_index = index_aa_dict.get(residue)

			if j == 0: 
				previous_residue = motif_seq[j+1]
				previous_residue_position = j + 1
			else: 
				previous_residue = motif_seq[j-1]
				previous_residue_position = j - 1

			if j == target_motif_length - 1: 
				subsequent_residue = motif_seq[j-1]
				subsequent_residue_position = j - 1
			else: 
				subsequent_residue = motif_seq[j+1]
				subsequent_residue_position = j + 1

			try: 
				previous_residue_characteristic = CharacAA(previous_residue) #returns the biochemical aa characteristic name
				subsequent_residue_characteristic = CharacAA(subsequent_residue)
			except: 
				print(motif_seq, "gave CharacAA error")
				print(stop)

			key1 = "#" + str(previous_residue_position + 1) + "=" + previous_residue_characteristic + "_#" + str(j + 1) + "_list"
			key2 = "#" + str(subsequent_residue_position + 1) + "=" + subsequent_residue_characteristic + "_#" + str(j + 1) + "_list"

			list_at_residue_for_previous = dictionary_of_weighted_lists.get(key1)
			list_at_residue_for_subsequent = dictionary_of_weighted_lists.get(key2)

			score_previous = list_at_residue_for_previous[residue_row_index]
			score_subsequent = list_at_residue_for_subsequent[residue_row_index]

			score_current_position = score_previous + score_subsequent
			score = score + score_current_position

		if score > first_score and motif_seq[7] in ["F", "Y"]: 
			second_score = first_score #Assigns the previously best score as the next-best
			second_motif = first_motif
			first_score = score #Assigns the new best score as best
			first_motif = motif_seq

	return first_motif, first_score, second_motif, second_score

#Define motif score assigning function
def motif_score_assigner(index, destination_dataframe, motif_length, screening_rules, append_leading_glycines = True, append_trailing_glycines = True):
	whole_sequence = destination_dataframe.at[index, "Sequence"]
	if append_leading_glycines:
		whole_sequence = ("G" * motif_length) + whole_sequence # To accommodate for motifs that are N-terminally truncated, treat truncated positions like Gly, which has no side chain
	if append_trailing_glycines:
		whole_sequence = whole_sequence + ("G" * motif_length)  # To accommodate for motifs that are N-terminally truncated, treat truncated positions like Gly, which has no side chain
	protein_length = len(whole_sequence) # Caution: if leading or trailing glycines are appended, this is the length after appending, not the original length

	best_SLiM, best_score, second_best_SLiM, second_best_score = motif_finder(whole_sequence, protein_length, motif_length, screening_rules)

	destination_dataframe.at[index, "Best_SLiM"] = best_SLiM
	destination_dataframe.at[index, "Best_SLiM_Score"] = best_score
	destination_dataframe.at[index, "Second_Best_SLiM"] = second_best_SLiM
	destination_dataframe.at[index, "Second_Best_SLiM_Score"] = second_best_score

	if input_private == "Y": 
		external_best_motif, external_best_score, external_runnerup_motif, external_runnerup_score = imported_scorer(whole_sequence, protein_length)

		destination_dataframe.at[index, "External_Best_SLiM"] = external_best_motif
		destination_dataframe.at[index, "External_Best_Score"] = external_best_score
		destination_dataframe.at[index, "External_Runner-up_SLiM"] = external_runnerup_motif
		destination_dataframe.at[index, "External_Runner-up_Score"] = external_runnerup_score

#--------------------------------------------------------------------------

# Main routine
def main(motif_length, protein_seqs_path, manual_rules, use_private_method = False, display_progress = True):
	if use_private_method:
		get_private_method()

	protein_seqs_df = pd.read_csv(protein_seqs_path)
	number_of_proteins = len(protein_seqs_df)

	# Iterate through all the protein sequences
	for i in np.arange(number_of_proteins):
		motif_score_assigner(index = i, destination_dataframe = protein_seqs_df, motif_length = motif_length, screening_rules = manual_rules)
		print("Completed", i, "of", number_of_proteins) if display_progress else None
	print("----------------")

	# Pickle the output file path so that it can be read by subsequent scripts
	output_filename = os.path.join(os.getcwd(), "Output", protein_seqs_path[:-4] + "_Scored_SLiMs.csv")
	with open("Step4_Output_Filename.ob", "wb") as f:
		pickle.dump(output_filename, f)

	protein_seqs_df.to_csv(output_filename)
	print("Output saved! Filename:", output_filename)
	print("----------------")

# Execute main routine if running as a standalone script
if __name__ == "__main__":
	# Determine whether to use a parallel scoring method, such as one from the literature, to compare to the method used by this module
	input_private = input("Do you want to import a parallel scoring method (outside of this repository) for comparison? (Y/N)  ")
	input_private = True if input_private == "Y" else False # convert to Boolean

	# Prompt the user for the length of the motif being scored. This can probably be automated to match the output of make_pairwise_matrices.py and should be done in a later release.
	motif_length_entered = False
	while not motif_length_entered:
		motif_length = input("Enter the length of the SLiM motif being predicted:  ")
		try:
			motif_length = int(motif_length)
			motif_length_entered = True
		except:
			print("\tInput must be an integer; please try again.")

	# Import conditional weighted matrices as generated by make_pairwise_matrices.py
	dictionary_of_weighted_matrices, dictionary_of_weighted_lists = import_weighted_matrices()

	# Prompt the user for the path to the protein sequences being analyzed
	data_path_given = False
	while not data_path_given:
		input_data_path = input("Enter the path to the protein sequence data as a CSV file:  ")
		if os.path.exists(input_data_path):
			data_path_given = True
		else:
			print("Path does not exist; please try again.")

	# Prompt the user to declare manual rejection criteria for motifs
	defined_rules = manual_rule_definer(motif_length)

	main(motif_length = motif_length, protein_seqs_path = input_data_path, manual_rules = defined_rules, use_private_method = input_private)